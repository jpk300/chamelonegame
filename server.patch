 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/server.js b/server.js
index 5ed29882e9d49348e502a9f93f1a8784e1cc34fa..e6bb6cd0cac6d9002a593b65aec53f18c653d0fb 100644
--- a/server.js
+++ b/server.js
@@ -6,113 +6,162 @@ const app = express();
 const server = http.createServer(app);
 const wss = new WebSocketServer({ server });
 
 const PORT = process.env.PORT || 3000;
 
 app.use(express.static("public"));
 
 const WORDS = [
   "volcano",
   "pineapple",
   "giraffe",
   "keyboard",
   "rainbow",
   "spaceship",
   "cucumber",
   "lighthouse",
   "backpack",
   "snowflake",
   "accordion",
   "mountain",
   "bicycle",
   "fireworks",
   "marshmallow"
 ];
 
+const CLUE_DURATION_MS = 12000;
+
 const state = {
   phase: "lobby",
   secretWord: null,
   chameleonId: null,
   clues: {},
   votes: {},
   timerEndsAt: null,
-  lastResult: null
+  lastResult: null,
+  clueOrder: [],
+  clueIndex: 0,
+  activeCluePlayerId: null,
+  clueTimeout: null
 };
 
 const players = new Map();
 
 function randomWord() {
   return WORDS[Math.floor(Math.random() * WORDS.length)];
 }
 
 function broadcast(payload) {
   const message = JSON.stringify(payload);
   for (const player of players.values()) {
     player.ws.send(message);
   }
 }
 
 function sendToPlayer(player, payload) {
   if (!player) return;
   player.ws.send(JSON.stringify(payload));
 }
 
 function publicState() {
   return {
     phase: state.phase,
     timerEndsAt: state.timerEndsAt,
+    activeCluePlayerId: state.activeCluePlayerId,
     players: Array.from(players.values()).map((player) => ({
       id: player.id,
       name: player.name,
       clue: state.clues[player.id] || null,
       vote: state.votes[player.id] || null
     })),
     lastResult: state.lastResult
   };
 }
 
 function resetRoundData() {
   state.secretWord = null;
   state.chameleonId = null;
   state.clues = {};
   state.votes = {};
   state.timerEndsAt = null;
   state.lastResult = null;
+  state.clueOrder = [];
+  state.clueIndex = 0;
+  state.activeCluePlayerId = null;
+  if (state.clueTimeout) {
+    clearTimeout(state.clueTimeout);
+    state.clueTimeout = null;
+  }
 }
 
-function startCluePhase() {
-  state.phase = "clue";
-  state.timerEndsAt = Date.now() + 7000;
+function shuffle(array) {
+  return array
+    .map((value) => ({ value, sort: Math.random() }))
+    .sort((a, b) => a.sort - b.sort)
+    .map(({ value }) => value);
+}
+
+function startVotePhase() {
+  state.phase = "vote";
+  state.timerEndsAt = null;
+  state.activeCluePlayerId = null;
+  if (state.clueTimeout) {
+    clearTimeout(state.clueTimeout);
+    state.clueTimeout = null;
+  }
   broadcast({ type: "state", data: publicState() });
+}
 
-  setTimeout(() => {
-    if (state.phase === "clue") {
-      state.phase = "vote";
-      state.timerEndsAt = null;
-      broadcast({ type: "state", data: publicState() });
+function startNextClueTurn() {
+  if (state.clueIndex >= state.clueOrder.length) {
+    startVotePhase();
+    return;
+  }
+
+  state.activeCluePlayerId = state.clueOrder[state.clueIndex];
+  state.timerEndsAt = Date.now() + CLUE_DURATION_MS;
+  broadcast({ type: "state", data: publicState() });
+
+  if (state.clueTimeout) {
+    clearTimeout(state.clueTimeout);
+  }
+
+  state.clueTimeout = setTimeout(() => {
+    if (state.phase !== "clue") return;
+    if (!state.clues[state.activeCluePlayerId]) {
+      state.clues[state.activeCluePlayerId] = "No hint";
     }
-  }, 7000);
+    state.clueIndex += 1;
+    startNextClueTurn();
+  }, CLUE_DURATION_MS);
+}
+
+function startCluePhase() {
+  state.phase = "clue";
+  state.clueOrder = shuffle(Array.from(players.keys()));
+  state.clueIndex = 0;
+  startNextClueTurn();
 }
 
 function startRound() {
   if (players.size < 3) {
     broadcast({
       type: "error",
       message: "Need at least 3 players to start a round."
     });
     return;
   }
 
   resetRoundData();
   state.secretWord = randomWord();
   const playerIds = Array.from(players.keys());
   state.chameleonId = playerIds[Math.floor(Math.random() * playerIds.length)];
 
   for (const player of players.values()) {
     sendToPlayer(player, {
       type: "secret",
       word: player.id === state.chameleonId ? null : state.secretWord
     });
   }
 
   startCluePhase();
 }
@@ -171,60 +220,81 @@ wss.on("connection", (ws) => {
   );
 
   ws.on("message", (raw) => {
     let message;
     try {
       message = JSON.parse(raw.toString());
     } catch (error) {
       return;
     }
 
     if (message.type === "join") {
       player.name = message.name?.trim() || "Player";
       broadcast({ type: "state", data: publicState() });
       return;
     }
 
     if (message.type === "start_round") {
       if (state.phase === "clue" || state.phase === "vote" || state.phase === "guess") {
         return;
       }
       startRound();
       return;
     }
 
     if (message.type === "submit_clue" && state.phase === "clue") {
-      state.clues[player.id] = message.clue?.trim() || "";
-      broadcast({ type: "state", data: publicState() });
+      if (player.id !== state.activeCluePlayerId) return;
+      if (state.clues[player.id]) return;
+      state.clues[player.id] = message.clue?.trim() || "No hint";
+      state.clueIndex += 1;
+      startNextClueTurn();
       return;
     }
 
     if (message.type === "submit_vote" && state.phase === "vote") {
       if (!players.has(message.targetId)) return;
       state.votes[player.id] = message.targetId;
       broadcast({ type: "state", data: publicState() });
 
       if (Object.keys(state.votes).length === players.size) {
         finishVoting();
       }
       return;
     }
 
     if (message.type === "chameleon_guess" && state.phase === "guess") {
       if (player.id !== state.chameleonId) return;
       handleGuess(message.guess || "");
     }
   });
 
   ws.on("close", () => {
     players.delete(playerId);
+    if (state.phase === "clue") {
+      const index = state.clueOrder.indexOf(playerId);
+      if (index !== -1) {
+        state.clueOrder.splice(index, 1);
+        if (index <= state.clueIndex && state.clueIndex > 0) {
+          state.clueIndex -= 1;
+        }
+      }
+      if (state.activeCluePlayerId === playerId) {
+        if (state.clueTimeout) {
+          clearTimeout(state.clueTimeout);
+          state.clueTimeout = null;
+        }
+        state.clues[playerId] = state.clues[playerId] || "Left the game";
+        state.clueIndex += 1;
+        startNextClueTurn();
+      }
+    }
     if (players.size === 0) {
       resetRoundData();
       state.phase = "lobby";
     }
     broadcast({ type: "state", data: publicState() });
   });
 });
 
 server.listen(PORT, () => {
   console.log(`Chameleon game server running on http://localhost:${PORT}`);
 });
 
EOF
)